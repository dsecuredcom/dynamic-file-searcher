package domain

import (
	"crypto/tls"
	"fmt"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/config"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/utils"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"
)

type domainProtocol struct {
	domain   string
	protocol string
}

var blacklistedWords = []string{
	"generated by cloudfront (cloudfront)",
	"errors&#46;edgesuite&#46;net",
}

func isBlacklisted(content string) bool {
	lowerContent := strings.ToLower(content)
	for _, word := range blacklistedWords {
		if strings.Contains(lowerContent, word) {
			return true
		}
	}
	return false
}

func checkDomainProtocol(domain string, cfg *config.Config) (string, bool) {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	makeRequest := func(protocol string) (*http.Response, error) {
		url := fmt.Sprintf("%s://%s", protocol, domain)
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return nil, err
		}

		// Set hardcoded headers
		req.Header.Set("Referer", url)
		req.Header.Set("Origin", url)
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")

		// Set extra headers from config
		for key, value := range cfg.ExtraHeaders {
			req.Header.Set(key, value)
		}

		return httpClient.Do(req)
	}

	// Try HTTPS first
	resp, err := makeRequest("https")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "https", false
	}

	// If HTTPS fails, try HTTP
	resp, err = makeRequest("http")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "http", false
	}

	// If both fail, default to HTTPS
	return "https", false
}

func checkDomainsProtocols(domains []string, workers int, cfg *config.Config) []domainProtocol {
	results := make([]domainProtocol, 0, len(domains))
	jobs := make(chan string, len(domains))
	resultsChan := make(chan domainProtocol, len(domains))

	var wg sync.WaitGroup

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for domain := range jobs {
				protocol, blacklisted := checkDomainProtocol(domain, cfg)
				if !blacklisted {
					resultsChan <- domainProtocol{domain: domain, protocol: protocol}
				}
			}
		}()
	}

	for _, domain := range domains {
		jobs <- domain
	}
	close(jobs)

	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		results = append(results, result)
	}

	return results
}

func GetDomains(domainsFile, singleDomain string) []string {
	if domainsFile != "" {
		allLines := utils.ReadLines(domainsFile)
		var validDomains []string
		for _, line := range allLines {
			trimmedLine := strings.TrimSpace(line)
			if trimmedLine != "" && !strings.HasPrefix(trimmedLine, "#") {
				validDomains = append(validDomains, trimmedLine)
			}
		}
		return validDomains
	}
	return []string{singleDomain}
}

func GenerateURLs(domains, paths []string, cfg *config.Config) ([]string, int) {
	domainProtocols := checkDomainsProtocols(domains, 25, cfg)

	var allURLs []string
	for _, dp := range domainProtocols {
		for _, path := range paths {
			allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s", dp.protocol, dp.domain, path))

			words := splitDomain(dp.domain)
			for _, word := range words {
				allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s/%s", dp.protocol, dp.domain, word, path))

				for _, basePath := range cfg.BasePaths {
					allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s/%s", dp.protocol, dp.domain, basePath, word, path))
				}
			}
		}
	}

	utils.ShuffleStrings(allURLs)

	return allURLs, len(domainProtocols)
}

func splitDomain(domain string) []string {
	if isIPAddress(domain) {
		return []string{}
	}

	parts := strings.Split(domain, ".")
	results := make(map[string]bool)

	results[domain] = true

	filteredParts := filterParts(parts)

	subdomainParts := filteredParts[:len(filteredParts)-2]
	domainParts := filteredParts[len(filteredParts)-2:]

	subdomain := strings.Join(subdomainParts, ".")
	results[subdomain] = true
	for _, part := range subdomainParts {
		results[part] = true
		results[part+"1"] = true
	}

	domain = strings.Join(domainParts, ".")
	results[domain] = true
	results[domainParts[0]] = true
	results[domainParts[0]+"1"] = true

	baseWords := []string{subdomain}
	baseWords = append(baseWords, subdomainParts...)
	baseWords = append(baseWords, domainParts[0])

	extendedWords := generateExtendedWords(baseWords)
	for _, word := range extendedWords {
		results[word] = true
	}

	finalResults := make([]string, 0, len(results))
	for word := range results {
		finalResults = append(finalResults, word)
	}

	return finalResults
}

func filterParts(parts []string) []string {
	var filteredParts []string
	for _, part := range parts {
		if !isRegion(part) {
			if isEnvironment(part) {
				envParts := strings.Split(part, "-")
				if len(envParts) > 1 {
					filteredParts = append(filteredParts, envParts[len(envParts)-1])
				}
			} else {
				filteredParts = append(filteredParts, part)
			}
		}
	}
	return filteredParts
}

func isRegion(s string) bool {
	regionPattern := regexp.MustCompile(`^[a-z]{2}-[a-z]+-\d+$`)
	return regionPattern.MatchString(s)
}

func isEnvironment(s string) bool {
	envPattern := regexp.MustCompile(`^(prod|dev|stage|test|qa|stg|uat)$`)
	return envPattern.MatchString(s)
}

func generateExtendedWords(baseWords []string) []string {
	suffixes := []string{"qa", "dev", "stage", "prod", "test", "stg", "uat", "admin"}
	var extendedWords []string
	for _, word := range baseWords {

		if word == "" {
			continue
		}

		if !strings.Contains(word, ".") {
			for _, suffix := range suffixes {
				extendedWords = append(extendedWords, word+"-"+suffix, word+suffix)
			}
		}
	}
	return extendedWords
}

func isIPAddress(s string) bool {
	ipPattern := regexp.MustCompile(`^(\d{1,3}\.){3}\d{1,3}$`)
	return ipPattern.MatchString(s)
}
