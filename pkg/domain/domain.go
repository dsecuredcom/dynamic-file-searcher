package domain

import (
	"crypto/tls"
	"fmt"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/config"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/utils"
	"github.com/schollz/progressbar/v3"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"
)

type domainProtocol struct {
	domain   string
	protocol string
}

var blacklistedWords = []string{
	"generated by cloudfront (cloudfront)",
	"errors&#46;edgesuite&#46;net",
}

var (
	ipv4Regex         = regexp.MustCompile(`^(\d{1,3}\.){3}\d{1,3}$`)
	ipv6Regex         = regexp.MustCompile(`^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$`)
	ipPartRegex       = regexp.MustCompile(`(\d{1,3}[-\.]\d{1,3}[-\.]\d{1,3}[-\.]\d{1,3})`)
	md5Regex          = regexp.MustCompile(`^[a-fA-F0-9]{32}$`)
	onlyAlphaRegex    = regexp.MustCompile(`^[a-z]+$`)
	envRegex          = regexp.MustCompile(`prod|qa|dev|stage|test|uat|stg|stg`)
	numberSuffixRegex = regexp.MustCompile(`\d+$`)
	envWords          = []string{"-prod", "-qa", "-dev", "-stage", "-test", "-uat", "-stg", "qa", "dev", "test"}
)

var commonTLDs = []string{
	// Multi-part TLDs
	"co.uk", "co.jp", "co.nz", "co.za", "com.au", "com.br", "com.cn", "com.mx", "com.tr", "com.tw",
	"edu.au", "edu.cn", "edu.hk", "edu.sg", "gov.uk", "net.au", "net.cn", "org.au", "org.uk",
	"ac.uk", "ac.nz", "ac.jp", "ac.kr", "ne.jp", "or.jp", "org.nz", "govt.nz", "sch.uk", "nhs.uk",

	// Generic TLDs (gTLDs)
	"com", "org", "net", "edu", "gov", "int", "mil", "aero", "biz", "cat", "coop", "info", "jobs",
	"mobi", "museum", "name", "pro", "tel", "travel", "xxx", "asia", "arpa",

	// New gTLDs
	"app", "dev", "io", "ai", "cloud", "digital", "online", "store", "tech", "site", "website",
	"blog", "shop", "agency", "expert", "software", "studio", "design", "education", "healthcare",

	// Country Code TLDs (ccTLDs)
	"ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw",
	"ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bm", "bn", "bo", "br", "bs",
	"bt", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn",
	"co", "cr", "cu", "cv", "cx", "cy", "cz", "de", "dj", "dk", "dm", "do", "dz", "ec", "ee", "eg",
	"er", "es", "et", "eu", "fi", "fj", "fk", "fm", "fo", "fr", "ga", "gb", "gd", "ge", "gf", "gg",
	"gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn",
	"hr", "ht", "hu", "id", "ie", "il", "im", "in", "io", "iq", "ir", "is", "it", "je", "jm", "jo",
	"jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li",
	"lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mg", "mh", "mk", "ml", "mm",
	"mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne",
	"nf", "ng", "ni", "nl", "no", "np", "nr", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk",
	"pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb",
	"sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "st", "su", "sv",
	"sy", "sz", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt",
	"tv", "tw", "tz", "ua", "ug", "uk", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu",
	"wf", "ws", "ye", "yt", "za", "zm", "zw",
}

func isBlacklisted(content string) bool {
	lowerContent := strings.ToLower(content)
	for _, word := range blacklistedWords {
		if strings.Contains(lowerContent, word) {
			return true
		}
	}
	return false
}

func checkDomainProtocol(domain string, cfg *config.Config) (string, bool) {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	makeRequest := func(protocol string) (*http.Response, error) {
		url := fmt.Sprintf("%s://%s", protocol, domain)
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Referer", url)
		req.Header.Set("Origin", url)
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")

		for key, value := range cfg.ExtraHeaders {
			req.Header.Set(key, value)
		}

		return httpClient.Do(req)
	}

	resp, err := makeRequest("https")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "https", false
	}

	resp, err = makeRequest("http")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "http", false
	}

	return "https", false
}

func checkDomainsProtocols(domains []string, workers int, cfg *config.Config) []domainProtocol {
	results := make([]domainProtocol, 0, len(domains))
	jobs := make(chan string, len(domains))
	resultsChan := make(chan domainProtocol, len(domains))

	var wg sync.WaitGroup

	bar := progressbar.Default(int64(len(domains)), "Checking protocols")

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for domain := range jobs {
				protocol, blacklisted := checkDomainProtocol(domain, cfg)
				if !blacklisted {
					resultsChan <- domainProtocol{domain: domain, protocol: protocol}
				}
				bar.Add(1)
			}
		}()
	}

	for _, domain := range domains {
		jobs <- domain
	}
	close(jobs)

	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		results = append(results, result)
	}

	return results
}

func GetDomains(domainsFile, singleDomain string) []string {
	if domainsFile != "" {
		allLines := utils.ReadLines(domainsFile)
		var validDomains []string
		for _, line := range allLines {
			trimmedLine := strings.TrimSpace(line)
			if trimmedLine != "" && !strings.HasPrefix(trimmedLine, "#") {
				validDomains = append(validDomains, trimmedLine)
			}
		}
		return validDomains
	}
	return []string{singleDomain}
}

func GenerateURLs(domains, paths []string, cfg *config.Config) ([]string, int) {
	var domainProtocols []domainProtocol

	if cfg.PerformProtocolCheck {
		domainProtocols = checkDomainsProtocols(domains, 100, cfg)
	} else {
		for _, d := range domains {
			domainProtocols = append(domainProtocols, domainProtocol{domain: d, protocol: "https"})
		}
	}

	var allURLs []string
	for _, dp := range domainProtocols {
		for _, path := range paths {
			allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s", dp.protocol, dp.domain, path))

			words := splitDomain(dp.domain)

			if len(cfg.BasePaths) == 0 {
				for _, word := range words {
					allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s/%s", dp.protocol, dp.domain, word, path))
				}
			} else {
				for _, word := range words {
					for _, basePath := range cfg.BasePaths {
						allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s/%s", dp.protocol, dp.domain, basePath, word, path))
					}
				}
			}
		}
	}

	utils.ShuffleStrings(allURLs)

	return allURLs, len(domainProtocols)
}

func splitDomain(host string) []string {

	if ipv4Regex.MatchString(host) || ipv6Regex.MatchString(host) {
		return []string{}
	}

	// Naive approach but lol
	host = ipPartRegex.ReplaceAllString(host, "")
	host = md5Regex.ReplaceAllString(host, "")
	host = removeTLD(host)

	parts := strings.Split(host, ".")

	relevantParts := parts
	if len(parts) > 3 {
		relevantParts = parts[:3]
	}

	var words []string
	for _, part := range relevantParts {
		words = CombineUniqueStringSlices(words, extractWords(part))
	}

	filteredWords := filterWords(words)

	return filteredWords
}

func extractWords(part string) []string {
	subparts := regexp.MustCompile(`[._-]`).Split(part, -1)

	words := make(map[string]bool)

	for _, subpart := range subparts {
		if subpart != "" {
			words[subpart] = true
		}

		if numberSuffixRegex.MatchString(subpart) {
			words[numberSuffixRegex.ReplaceAllString(subpart, "")] = true
		}

	}

	for subpart, _ := range words {
		if onlyAlphaRegex.MatchString(subpart) {

			if envRegex.MatchString(subpart) {
				continue
			}
			for _, word := range envWords {
				if strings.Contains(subpart, word) {
					break
				}

				words[subpart+word] = true
			}
		}
	}

	words[part] = true

	if strings.Contains(part, "-") {
		hyphenParts := strings.Split(part, "-")
		for i := 1; i <= len(hyphenParts); i++ {
			words[strings.Join(hyphenParts[:i], "-")] = true
		}

		for _, hyphenPart := range hyphenParts[1:] {
			words[hyphenPart] = true
		}
	}

	var FilteredWords []string
	for word := range words {
		FilteredWords = append(FilteredWords, word)
	}

	return FilteredWords
}

func filterWords(words []string) []string {
	var filteredWords []string
	for _, word := range words {
		if !shouldFilterWord(word) {
			filteredWords = append(filteredWords, word)
		}
	}
	return filteredWords
}

func shouldFilterWord(word string) bool {

	if strings.Count(word, "-")+strings.Count(word, "_") > 2 {
		return true
	}

	for _, env := range envWords {
		if strings.HasPrefix(word, env) {
			return true
		}
	}

	return false
}

func CombineUniqueStringSlices(slice1, slice2 []string) []string {
	uniqueMap := make(map[string]bool)

	for _, s := range slice1 {
		uniqueMap[s] = true
	}
	for _, s := range slice2 {
		uniqueMap[s] = true
	}

	combined := make([]string, 0, len(uniqueMap))
	for s := range uniqueMap {
		combined = append(combined, s)
	}

	return combined
}

func removeTLD(host string) string {
	host = strings.ToLower(host)
	parts := strings.Split(host, ".")

	for i := 0; i < len(parts); i++ {
		potentialTLD := strings.Join(parts[i:], ".")
		for _, tld := range commonTLDs {
			if potentialTLD == tld {
				return strings.Join(parts[:i], ".")
			}
		}
	}

	return host
}
