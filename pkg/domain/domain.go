package domain

import (
	"crypto/tls"
	"fmt"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/config"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/utils"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"
)

type domainProtocol struct {
	domain   string
	protocol string
}

var blacklistedWords = []string{
	"generated by cloudfront (cloudfront)",
	"errors&#46;edgesuite&#46;net",
}

func isBlacklisted(content string) bool {
	lowerContent := strings.ToLower(content)
	for _, word := range blacklistedWords {
		if strings.Contains(lowerContent, word) {
			return true
		}
	}
	return false
}

func checkDomainProtocol(domain string) (string, bool) {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	resp, err := httpClient.Get(fmt.Sprintf("https://%s", domain))
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		//fmt.Printf("%s\n", body)
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "https", false
	}

	resp, err = httpClient.Get(fmt.Sprintf("http://%s", domain))
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "http", false
	}

	return "https", false
}

func checkDomainsProtocols(domains []string, workers int) []domainProtocol {
	results := make([]domainProtocol, 0, len(domains))
	jobs := make(chan string, len(domains))
	resultsChan := make(chan domainProtocol, len(domains))

	var wg sync.WaitGroup

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for domain := range jobs {
				protocol, blacklisted := checkDomainProtocol(domain)
				if !blacklisted {
					resultsChan <- domainProtocol{domain: domain, protocol: protocol}
				}
			}
		}()
	}

	for _, domain := range domains {
		jobs <- domain
	}
	close(jobs)

	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		results = append(results, result)
	}

	return results
}

func GetDomains(domainsFile, singleDomain string) []string {
	if domainsFile != "" {
		return utils.ReadLines(domainsFile)
	}
	return []string{singleDomain}
}

func GenerateURLs(domains, paths []string, cfg *config.Config) ([]string, int) {
	domainProtocols := checkDomainsProtocols(domains, 25)

	var allURLs []string
	for _, dp := range domainProtocols {
		for _, path := range paths {
			allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s", dp.protocol, dp.domain, path))

			words := splitDomain(dp.domain)
			for _, word := range words {
				allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s/%s", dp.protocol, dp.domain, word, path))

				for _, basePath := range cfg.BasePaths {
					allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s/%s", dp.protocol, dp.domain, basePath, word, path))
				}
			}
		}
	}

	utils.ShuffleStrings(allURLs)

	return allURLs, len(domainProtocols)
}

func splitDomain(domain string) []string {
	if isIPAddress(domain) {
		return []string{}
	}

	parts := strings.Split(domain, ".")
	results := make(map[string]bool)

	results[domain] = true

	filteredParts := filterParts(parts)

	subdomainParts := filteredParts[:len(filteredParts)-2]
	domainParts := filteredParts[len(filteredParts)-2:]

	subdomain := strings.Join(subdomainParts, ".")
	results[subdomain] = true
	for _, part := range subdomainParts {
		results[part] = true
		results[part+"1"] = true
		results[part+"123"] = true
	}

	domain = strings.Join(domainParts, ".")
	results[domain] = true
	results[domainParts[0]] = true
	results[domainParts[0]+"1"] = true
	results[domainParts[0]+"123"] = true

	baseWords := []string{subdomain}
	baseWords = append(baseWords, subdomainParts...)
	baseWords = append(baseWords, domainParts[0])

	extendedWords := generateExtendedWords(baseWords)
	for _, word := range extendedWords {
		results[word] = true
	}

	finalResults := make([]string, 0, len(results))
	for word := range results {
		finalResults = append(finalResults, word)
	}

	return finalResults
}

func filterParts(parts []string) []string {
	var filteredParts []string
	for _, part := range parts {
		if !isRegion(part) {
			if isEnvironment(part) {
				envParts := strings.Split(part, "-")
				if len(envParts) > 1 {
					filteredParts = append(filteredParts, envParts[len(envParts)-1])
				}
			} else {
				filteredParts = append(filteredParts, part)
			}
		}
	}
	return filteredParts
}

func isRegion(s string) bool {
	regionPattern := regexp.MustCompile(`^[a-z]{2}-[a-z]+-\d+$`)
	return regionPattern.MatchString(s)
}

func isEnvironment(s string) bool {
	envPattern := regexp.MustCompile(`^(prod|dev|stage|test|qa|stg|uat)$`)
	return envPattern.MatchString(s)
}

func generateExtendedWords(baseWords []string) []string {
	suffixes := []string{"qa", "dev", "stage", "prod", "test", "stg", "uat", "admin", "adm", "backup", "bak", "old", "new"}
	var extendedWords []string
	for _, word := range baseWords {

		if word == "" {
			continue
		}

		if !strings.Contains(word, ".") {
			for _, suffix := range suffixes {
				extendedWords = append(extendedWords, word+"-"+suffix, word+suffix)
			}
		}
	}
	return extendedWords
}

func isIPAddress(s string) bool {
	ipPattern := regexp.MustCompile(`^(\d{1,3}\.){3}\d{1,3}$`)
	return ipPattern.MatchString(s)
}
