package domain

import (
	"crypto/tls"
	"fmt"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/config"
	"github.com/dsecuredcom/dynamic-file-searcher/pkg/utils"
	"github.com/schollz/progressbar/v3"
	"io"
	"net/http"
	"regexp"
	"strings"
	"sync"
	"time"
)

type domainProtocol struct {
	domain   string
	protocol string
}

var blacklistedWords = []string{
	"generated by cloudfront (cloudfront)",
	"errors&#46;edgesuite&#46;net",
}

var (
	ipv4Regex         = regexp.MustCompile(`^(\d{1,3}\.){3}\d{1,3}$`)
	ipv6Regex         = regexp.MustCompile(`^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$`)
	ipPartRegex       = regexp.MustCompile(`(\d{1,3}[-\.]\d{1,3}[-\.]\d{1,3}[-\.]\d{1,3})`)
	md5Regex          = regexp.MustCompile(`^[a-fA-F0-9]{32}$`)
	onlyAlphaRegex    = regexp.MustCompile(`^[a-z]+$`)
	envRegex          = regexp.MustCompile(`prod|qa|dev|stage|test|uat|stg|stg`)
	numberSuffixRegex = regexp.MustCompile(`\d+$`)
	envWords          = []string{"-prod", "-qa", "-dev", "-stage", "-test", "-uat", "-stg", "qa", "dev", "test", "-v1", "-v2", "1"}
	regionPartRegex   = regexp.MustCompile(`(us-east-1|us-east-2|us-west-1|us-west-2|af-south-1|ap-east-1|ap-south-1|ap-northeast-3|ap-northeast-2|ap-southeast-1|ap-southeast-2|ap-northeast-1|ca-central-1|eu-central-1|eu-west-1|eu-west-2|eu-west-3|eu-north-1|eu-south-1|me-south-1|sa-east-1)`)
	singleDigitRegex  = regexp.MustCompile(`^(\d{1})$`)
	singleCharRegex   = regexp.MustCompile(`^([a-z]{1,1})$`)
)

var commonTLDs = []string{
	// Multi-part TLDs
	"co.uk", "co.jp", "co.nz", "co.za", "com.au", "com.br", "com.cn", "com.mx", "com.tr", "com.tw",
	"edu.au", "edu.cn", "edu.hk", "edu.sg", "gov.uk", "net.au", "net.cn", "org.au", "org.uk",
	"ac.uk", "ac.nz", "ac.jp", "ac.kr", "ne.jp", "or.jp", "org.nz", "govt.nz", "sch.uk", "nhs.uk",

	// Generic TLDs (gTLDs)
	"com", "org", "net", "edu", "gov", "int", "mil", "aero", "biz", "cat", "coop", "info", "jobs",
	"mobi", "museum", "name", "pro", "tel", "travel", "xxx", "asia", "arpa",

	// New gTLDs
	"app", "dev", "io", "ai", "cloud", "digital", "online", "store", "tech", "site", "website",
	"blog", "shop", "agency", "expert", "software", "studio", "design", "education", "healthcare",

	// Country Code TLDs (ccTLDs)
	"ac", "ad", "ae", "af", "ag", "ai", "al", "am", "an", "ao", "aq", "ar", "as", "at", "au", "aw",
	"ax", "az", "ba", "bb", "bd", "be", "bf", "bg", "bh", "bi", "bj", "bm", "bn", "bo", "br", "bs",
	"bt", "bv", "bw", "by", "bz", "ca", "cc", "cd", "cf", "cg", "ch", "ci", "ck", "cl", "cm", "cn",
	"co", "cr", "cu", "cv", "cx", "cy", "cz", "de", "dj", "dk", "dm", "do", "dz", "ec", "ee", "eg",
	"er", "es", "et", "eu", "fi", "fj", "fk", "fm", "fo", "fr", "ga", "gb", "gd", "ge", "gf", "gg",
	"gh", "gi", "gl", "gm", "gn", "gp", "gq", "gr", "gs", "gt", "gu", "gw", "gy", "hk", "hm", "hn",
	"hr", "ht", "hu", "id", "ie", "il", "im", "in", "io", "iq", "ir", "is", "it", "je", "jm", "jo",
	"jp", "ke", "kg", "kh", "ki", "km", "kn", "kp", "kr", "kw", "ky", "kz", "la", "lb", "lc", "li",
	"lk", "lr", "ls", "lt", "lu", "lv", "ly", "ma", "mc", "md", "me", "mg", "mh", "mk", "ml", "mm",
	"mn", "mo", "mp", "mq", "mr", "ms", "mt", "mu", "mv", "mw", "mx", "my", "mz", "na", "nc", "ne",
	"nf", "ng", "ni", "nl", "no", "np", "nr", "nu", "nz", "om", "pa", "pe", "pf", "pg", "ph", "pk",
	"pl", "pm", "pn", "pr", "ps", "pt", "pw", "py", "qa", "re", "ro", "rs", "ru", "rw", "sa", "sb",
	"sc", "sd", "se", "sg", "sh", "si", "sj", "sk", "sl", "sm", "sn", "so", "sr", "st", "su", "sv",
	"sy", "sz", "tc", "td", "tf", "tg", "th", "tj", "tk", "tl", "tm", "tn", "to", "tp", "tr", "tt",
	"tv", "tw", "tz", "ua", "ug", "uk", "us", "uy", "uz", "va", "vc", "ve", "vg", "vi", "vn", "vu",
	"wf", "ws", "ye", "yt", "za", "zm", "zw",
}

func isBlacklisted(content string) bool {
	lowerContent := strings.ToLower(content)
	for _, word := range blacklistedWords {
		if strings.Contains(lowerContent, word) {
			return true
		}
	}
	return false
}

func checkDomainProtocol(domain string, cfg *config.Config) (string, bool) {
	transport := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	httpClient := &http.Client{
		Transport: transport,
		Timeout:   10 * time.Second,
		CheckRedirect: func(req *http.Request, via []*http.Request) error {
			return http.ErrUseLastResponse
		},
	}

	makeRequest := func(protocol string) (*http.Response, error) {
		url := fmt.Sprintf("%s://%s", protocol, domain)
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Referer", url)
		req.Header.Set("Origin", url)
		req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36")

		for key, value := range cfg.ExtraHeaders {
			req.Header.Set(key, value)
		}

		return httpClient.Do(req)
	}

	resp, err := makeRequest("https")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "https", false
	}

	resp, err = makeRequest("http")
	if err == nil {
		defer resp.Body.Close()
		body, _ := io.ReadAll(io.LimitReader(resp.Body, 1024)) // Read first 1KB
		if isBlacklisted(string(body)) {
			return "", true
		}
		return "http", false
	}

	return "https", false
}

func checkDomainsProtocols(domains []string, workers int, cfg *config.Config) []domainProtocol {
	results := make([]domainProtocol, 0, len(domains))
	jobs := make(chan string, len(domains))
	resultsChan := make(chan domainProtocol, len(domains))

	var wg sync.WaitGroup

	bar := progressbar.Default(int64(len(domains)), "Checking protocols")

	for i := 0; i < workers; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for domain := range jobs {
				protocol, blacklisted := checkDomainProtocol(domain, cfg)
				if !blacklisted {
					resultsChan <- domainProtocol{domain: domain, protocol: protocol}
				}
				bar.Add(1)
			}
		}()
	}

	for _, domain := range domains {
		jobs <- domain
	}
	close(jobs)

	go func() {
		wg.Wait()
		close(resultsChan)
	}()

	for result := range resultsChan {
		results = append(results, result)
	}

	return results
}

func GetDomains(domainsFile, singleDomain string) []string {
	if domainsFile != "" {
		allLines := utils.ReadLines(domainsFile)
		var validDomains []string
		for _, line := range allLines {
			trimmedLine := strings.TrimSpace(line)
			if trimmedLine != "" && !strings.HasPrefix(trimmedLine, "#") {
				validDomains = append(validDomains, trimmedLine)
			}
		}
		return validDomains
	}
	return []string{singleDomain}
}

func GenerateURLs(domains, paths []string, cfg *config.Config) ([]string, int) {
	var domainProtocols []domainProtocol

	if cfg.PerformProtocolCheck {
		domainProtocols = checkDomainsProtocols(domains, 100, cfg)
	} else {
		for _, d := range domains {
			domainProtocols = append(domainProtocols, domainProtocol{domain: d, protocol: "https"})
		}
	}

	var allURLs []string
	var slash string
	if cfg.DontPrependSlash {
		slash = ""
	} else {
		slash = "/"
	}
	for _, dp := range domainProtocols {
		for _, path := range paths {
			allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s", dp.protocol, dp.domain, slash, path))

			if len(cfg.BasePaths) > 0 {
				for _, basePath := range cfg.BasePaths {
					allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s%s", dp.protocol, dp.domain, basePath, slash, path))
				}
			}

			if cfg.DontGeneratePaths == true {
				continue
			}

			words := splitDomain(dp.domain, cfg)

			if len(cfg.BasePaths) == 0 {
				for _, word := range words {
					allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s%s%s", dp.protocol, dp.domain, word, slash, path))
				}
			} else {
				for _, word := range words {
					for _, basePath := range cfg.BasePaths {
						allURLs = append(allURLs, fmt.Sprintf("%s://%s/%s/%s%s%s", dp.protocol, dp.domain, basePath, word, slash, path))
					}
				}
			}
		}
	}

	utils.ShuffleStrings(allURLs)

	return allURLs, len(domainProtocols)
}

func splitDomain(host string, cfg *config.Config) []string {

	if ipv4Regex.MatchString(host) || ipv6Regex.MatchString(host) {
		return []string{}
	}

	// Naive approach but lol
	host = ipPartRegex.ReplaceAllString(host, "")
	host = md5Regex.ReplaceAllString(host, "")
	host = removeTLD(host)

	parts := strings.Split(host, ".")

	var RelevantPaths []string
	cutset := "._-"
	for _, part := range parts {

		if singleDigitRegex.MatchString(part) {
			continue
		}

		if singleCharRegex.MatchString(part) {
			continue
		}

		part = regionPartRegex.ReplaceAllString(part, "")

		part = strings.TrimRight(strings.TrimLeft(part, cutset), cutset)
		RelevantPaths = append(RelevantPaths, part)
	}

	//fmt.Println(RelevantPaths)
	//syscall.Exit(1)

	// Limit to host-depth, take the first X parts
	if cfg.HostDepth > 0 && len(RelevantPaths) > cfg.HostDepth {
		RelevantPaths = RelevantPaths[:cfg.HostDepth]
	}

	var words []string

	for _, part := range RelevantPaths {
		words = CombineUniqueStringSlices(words, extractWords(part, cfg))

		if cfg.UseStaticWordSeparator && len(cfg.StaticWords) > 0 && onlyAlphaRegex.MatchString(part) {
			for _, staticword := range cfg.StaticWords {
				if strings.Contains(part, staticword) {
					words = append(words, staticword)
					words = append(words, strings.ReplaceAll(part, staticword, ""))
				}
			}
		}

	}

	filteredWords := filterWords(words)

	return filteredWords
}

func extractWords(part string, cfg *config.Config) []string {
	subparts := regexp.MustCompile(`[._-]`).Split(part, -1)

	words := make(map[string]bool)

	for _, subpart := range subparts {
		if subpart != "" {
			words[subpart] = true
		}

		if numberSuffixRegex.MatchString(subpart) {
			words[numberSuffixRegex.ReplaceAllString(subpart, "")] = true
		}

	}

	if cfg.DontGeneratePaths == true {
		for subpart, _ := range words {
			if onlyAlphaRegex.MatchString(subpart) {

				if envRegex.MatchString(subpart) {
					continue
				}

				for _, word := range envWords {
					if strings.Contains(subpart, word) {
						break
					}

					words[subpart+word] = true
				}
			}
		}
	}

	words[part] = true

	if strings.Contains(part, "-") {
		hyphenParts := strings.Split(part, "-")
		for i := 1; i <= len(hyphenParts); i++ {
			words[strings.Join(hyphenParts[:i], "-")] = true
		}

		for _, hyphenPart := range hyphenParts[1:] {
			words[hyphenPart] = true
		}
	}

	var FilteredWords []string
	for word := range words {
		FilteredWords = append(FilteredWords, word)
	}

	return FilteredWords
}

func filterWords(words []string) []string {
	var filteredWords []string
	for _, word := range words {
		if !shouldFilterWord(word) {
			filteredWords = append(filteredWords, word)
		}
	}
	return filteredWords
}

func shouldFilterWord(word string) bool {

	if strings.Count(word, "-")+strings.Count(word, "_") > 2 {
		return true
	}

	// @todo: add more filters
	// makes no sense, check here.
	for _, env := range envWords {
		if strings.HasPrefix(word, env) {
			return true
		}
	}

	return false
}

func CombineUniqueStringSlices(slice1, slice2 []string) []string {
	uniqueMap := make(map[string]bool)

	for _, s := range slice1 {
		uniqueMap[s] = true
	}
	for _, s := range slice2 {
		uniqueMap[s] = true
	}

	combined := make([]string, 0, len(uniqueMap))
	for s := range uniqueMap {
		combined = append(combined, s)
	}

	return combined
}

func removeTLD(host string) string {
	host = strings.ToLower(host)
	parts := strings.Split(host, ".")

	for i := 0; i < len(parts); i++ {
		potentialTLD := strings.Join(parts[i:], ".")
		for _, tld := range commonTLDs {
			if potentialTLD == tld {
				return strings.Join(parts[:i], ".")
			}
		}
	}

	return host
}
